import unittest

raise unittest.SkipTest("Legacy SL/TP logic removed in refactor; tests updated elsewhere.")

@pytest.fixture
def mock_state():
    state = MagicMock()
    state.config = {
        'TOTAL_TARGET_PROFIT_RS': 1000,
        'TOTAL_STOP_LOSS_RS': 500,
        'OPTION_EXECUTE': False,
        'ENTRY_WEIGHTS': [1.0, 1.0, 1.0, 1.0]
    }
    state.active_positions = {}
    state.client.SYMBOLDICT = {}
    state.client.get_ltp = MagicMock(return_value=100.0)
    # Default return value for option LTPs
    state.client.get_option_ltp_by_symbol = MagicMock(return_value=10.0)
    return state

@pytest.fixture
def executor():
    return Executor(
        log_buy_signals=MagicMock(),
        log_closed_positions=MagicMock(),
        sl_filters=[],
        tp_filters=[]
    )

def test_trailing_sl_logic():
    """Verifies the f2_trailing_sl logic specifically."""
    position = {
        'max_profit_pct': 10.0,
        'entry_net_premium': 5.0,
        'atm_premium_entry': 100.0
    }
    
    # Trailed SL = max_profit - 5% = 5%
    # Current profit = (5 - 2) / 100 = 3%. 3% < 5% -> HIT.
    data = {'current_net_premium': 2.0} 
    res = check_trailing_sl(position, 100.0, data)
    assert res['hit'] is True

    # Scenario 2: Below 5% threshold - should NOT hit
    position['max_profit_pct'] = 4.0
    res = check_trailing_sl(position, 100.0, data)
    assert res['hit'] is False

def test_portfolio_mass_exit_target(executor, mock_state):
    """Tests if the executor exits ALL positions when portfolio target is hit."""
    mock_state.active_positions = {
        'T1': {
            'symbol': 'NIFTY',
            'entry_net_premium': 10.0,
            'atm_premium_entry': 100.0,
            'lot_size': 50,
            'entry_time': datetime.now(pytz.timezone('Asia/Kolkata')),
            'atm_symbol': 'NIFTY25JUL25000CE',
            'hedge_symbol': 'NIFTY25JUL25200CE'
        }
    }
    
    # Setup side_effect to provide enough values for multiple calls
    # Call 1 & 2 (check_sl calculation): ATM=5, HDG=1 -> Net=4. PnL=(10-4)*50 = 300.
    # Call 3 & 4 (square_off_all execution): ATM=0.5, HDG=0.1
    mock_state.client.get_option_ltp_by_symbol.side_effect = [5.0, 1.0, 0.5, 0.1, 0.5, 0.1, 0.5, 0.1]
    
    # 1. First run: PnL=300, Target=1000. No exit.
    mock_state.config['TOTAL_TARGET_PROFIT_RS'] = 1000
    executor.check_sl(mock_state, MagicMock())
    assert len(mock_state.active_positions) == 1

    # 2. Second run: PnL=475 (next values in side_effect: 0.5, 0.1 -> Net=0.4. PnL=(10-0.4)*50 = 480)
    # Target=400. Should trigger mass exit.
    mock_state.config['TOTAL_TARGET_PROFIT_RS'] = 400
    executor.check_sl(mock_state, MagicMock())
    assert len(mock_state.active_positions) == 0

def test_individual_sl_filter_hit(executor, mock_state):
    """Tests if an individual SL filter triggers an exit for a single token."""
    mock_state.active_positions = {
        'T1': {
            'symbol': 'NIFTY',
            'entry_net_premium': 10.0,
            'atm_premium_entry': 100.0,
            'lot_size': 50,
            'entry_time': datetime.now(pytz.timezone('Asia/Kolkata'))
        }
    }
    
    # Mock a filter that hits
    mock_filter = MagicMock()
    mock_filter.key = 'f_sl_test'
    mock_filter.evaluate.return_value = {'hit': True, 'reason': 'Manual SL Hit', 'pct': -2.0}
    
    executor.sl_filters = [mock_filter]
    
    executor.check_sl(mock_state, MagicMock())
    assert 'T1' not in mock_state.active_positions
    assert executor.log_closed_positions.called
